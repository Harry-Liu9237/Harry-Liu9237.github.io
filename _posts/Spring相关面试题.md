<h1>微服务是如何进行通信的?</h1>
<p>同步：RPC、RESTful HTTP协议</p>
<p>异步：消息队列。要考虑消息可靠传输、高性能以及编程模型的变化</p>
<h2>消息队列中间件如何选型</h2>
<p>1.协议：AMQP、STOMP、MQTT、私有协议等。</p>
<p>2.消息是否需要持久化。</p>
<p>3.吞吐量。</p>
<p>4.高可用支持，是否单点。</p>
<p>5.分布式扩展能力。</p>
<p>6.消息堆积能力和重放能力。</p>
<p>7.开发便捷，易于维护。</p>
<p>8.社区成熟度。</p>
<h1>SpringCloud五大核心组件</h1>
<p>1.Eureka是服务架构的注册中心，专门负责服务的注册和发现;</p>
<p>2.Feign：调用Feign创建的动态代理，Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址，
最后针对这个地址，发起请求、解析响应</p>
<p>3.Ribbon：他的作用是负载均衡，Ribbon的负载均衡默认的使用RoundRobin轮询算法
Ribbon是和Feign以及Eureka紧密协作，完成工作的，具体如下：
首先Ribbon会从 Eureka Client里面获取到对应的服务注册表,也就知道了所有的服务都部署在了那台机器上,在监听哪些端口,
然后Ribbon就可以使用默认的Round Robin算法, 从中选择一台机器, Feigin就会针对这些机器构造并发送请求</p>
<p>4.Hystrix：Hystrix是隔离、熔断以及降级的一个框架。啥意思说白了就是Hystrix会搞很多小线程池,每个小线程池里的线程仅用去请求的服务</p>
<p>5.zull：微服务网关,这个组件是负责网络路由的!</p>
总结：
Eureka:个服务启动时,Eureka会将服务注册到EurekaService,并且EurakeClient还可以返回过来从EurekaService拉去注册表,从而知道服务在哪里

Ribbon:服务间发起请求的时候,基于Ribbon服务做到负载均衡,从一个服务的对台机器中选择一台

Feign:基于fegin的动态代理机制,根据注解和选择机器,拼接Url地址,发起请求



Hystrix:发起的请求是通过Hystrix的线程池来走,不同的服走不同的线程池,实现了不同的服务调度隔离,避免服务雪崩的问题 

Zuul:如果前端后端移动端调用后台系统,统一走zull网关进入,有zull网关转发请求给对应的服务

<h1>Spring事务管理之几种方式实现事务</h1>
<h2>1、事务认识</h2>
<p>大家所了解的事务Transaction，它是一些列严密操作动作，要么都操作完成，要么都回滚撤销。Spring事务管理基于底层数据库本身的事务处理机制。数据库事务的基础，是掌握Spring事务管理的基础。这篇总结下Spring事务。
事务具备ACID四种特性，ACID是Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）的英文缩写。</p>
<p>（1）原子性（Atomicity）</p>
<p>事务最基本的操作单元，要么全部成功，要么全部失败，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
<p>（2）一致性（Consistency）</p>
<p>事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。</p>
<p>（3）隔离性（Isolation）</p>
<p>指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p>
<p>（4）持久性（Durability）</p>
<p>指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。</p>
<h2>2、事务的传播特性 </h2>
<p>事务传播行为就是多个事务方法调用时，如何定义方法间事务的传播。Spring定义了7中传播行为：</p>
<p>（1）propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是Spring默认的选择。</p>
<p>（2）propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</p>
<p>（3）propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</p>
<p>（4）propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。</p>
<p>（5）propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>
<p>（6）propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</p>
<p>（7）propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作。</p>
<h2>3、事务的隔离级别</h2>
<p>（1）read uncommited：是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。</p>
<p>（2）read commited：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。</p>
<p>（3）repeatable read：这种事务隔离级别可以防止脏读，不可重复读。但是可能会出现幻象读。它除了保证一个事务不能被另外一个事务读取未提交的数据之外还避免了以下情况产生（不可重复读）。</p>
<p>（4）serializable：这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读之外，还避免了幻象读</p>
<p>（5）脏读、不可重复读、幻象读概念说明：
a.脏读：指当一个事务正字访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作肯能是不正确的。
b.不可重复读：指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。
c.幻象读：一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻象读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）</p>
<h2>4、事务几种实现方式</h2>
<p>（1）编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。</p>
<p>（2）基于 TransactionProxyFactoryBean的声明式事务管理</p>
<p>（3）基于 @Transactional 的声明式事务管理</p>
<p>（4）基于Aspectj AOP配置事务</p>
<h1>Spring中有哪些不同的通知类型</h1>
<p>1.前置通知(Before Advice): 在连接点之前执行的Advice，不过除非它抛出异常，否则没有能力中断执行流。使用 @Before 注解使用这个Advice。</p>
<p>2.返回之后通知(After Retuning Advice): 在连接点正常结束之后执行的Advice。例如，如果一个方法没有抛出异常正常返回。通过 @AfterReturning 关注使用它。</p>
<p>3.抛出（异常）后执行通知(After Throwing Advice): 如果一个方法通过抛出异常来退出的话，这个Advice就会被执行。通用 @AfterThrowing 注解来使用。</p>
<p>4.后置通知(After Advice): 无论连接点是通过什么方式退出的(正常返回或者抛出异常)都会执行在结束后执行这些Advice。通过 @After 注解使用。</p>
<p>5.围绕通知(Around Advice): 围绕连接点执行的Advice，就你一个方法调用。这是最强大的Advice。通过 @Around 注解使用。</p>
<h1>Spring AOP常见面试题</h1>
<h2>AOP是什么？</h2>
<p>与OOP对比，面向切面，传统的OOP开发中的代码逻辑是至上而下的过程中会长生一些横切性问题，这些横切性的问题和我们的主业务逻辑关系不会散落在代码的各个地方，造成难以维护，AOP的编程思想就是把业务逻辑和横切的问题进行分离，从而达到解耦的目的，使代码的重用性和开发效率高（目的是重用代码，把公共的代码抽取出来）</p>
<h2>AOP的应用场景有哪些呢？</h2>
<p>1、日志记录 2、权限验证 3、效率检查（个人在代码上，喜欢用注解+切面，实现校验，redis分布式锁等功能）4、事务管理（spring 的事务就是用AOP实现的</p>
<h2>springAop的底层是怎样实现的？</h2>
<p>1、JDK动态代理 2、CGLIB代理</p>
<h3>是编译时期进行织入，还是运行期进行织入？</h3>
<p>运行期，生成字节码，再加载到虚拟机中，JDK是利用反射原理，CGLIB使用了ASM原理。</p>
<h3>初始化时期织入还是获取对象时织入？</h3>
<p>初始化的时候，已经将目标对象进行代理，放入到spring 容器中</p>
<h3>spring AOP 默认使用jdk动态代理还是cglib？</h3>
<p>要看条件，如果实现了接口的类，是使用jdk。如果没实现接口，就使用cglib</p>
<h2>spring AOP 和 AspectJ的关系？</h2>
<p>1、两者都是为了实现AOP这个目的，而出现的技术，spring aop 参考 AspectJ编程风格</p>
<h3>能不能简单说下AOP中的切面、切点、连接点、通知，四者的关系？</h3>
<p>aspect 切面</p>
<p>Point cut （如果理解了这个切点的概念，就在应用方面完全是可以的了）表示连接点的集合（类似一个表）</p>
<p>Join point 目标对象中的方法（每一条记录）</p>
<p>weaving 把代理逻辑加入到目标对象上的过程叫做织入</p>
<p>advice 通知类型</p>
