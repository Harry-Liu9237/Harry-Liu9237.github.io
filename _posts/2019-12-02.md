---
layout:     post                    # 使用的布局（不需要改）
title:      My First Post               # 标题 
subtitle:   Hello World, Hello Blog #副标题
date:       2019-12-02              # 时间
author:     Harry-Liu                     # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 生活
---
一、分布式锁应该具备哪些条件？
1.在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行
2.高可用的获取锁与释放锁
3.高性能的获取锁与释放锁
4.具备可重入特性
5.具备锁失效机制，防止死锁
6.具备非阻塞锁特性，即没有获取到锁将直接返回锁失败
二、分布式锁的三种实现方式:1.基于数据库实现分布式锁 2.基于缓存(redis)实现分布式锁 3.基于Zookeeper实现分布式锁
三、基于数据库的实现方式的实现方式很简单，但是它有一些问题需要解决和优化：
1.因为是基于数据库实现的，所以数据库的可用性和性能直接影响分布式锁的可用性和性能，所以数据库需要双机部署、数据同步、主备切换；
2.不具备可重入的特性，因为同一个线程在释放锁之前，行数据一致存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取锁的机器和线程信息，
在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁
3.没有锁失效机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后，一直获取不到锁，所以，需要在表中新增一列，用于记录
失效时间，并且需要定时清理这些失效数据
4.不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取
5.在实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑
四、选用Redis实现分布式锁原因
1.Redis有很有的性能
2.Redis命令对此支持很好，实现起来比较方便
五、Redis分布式锁实现思想：1.获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值是一个随机生成
的UUID，通过此在释放锁的时候进行判断
2.获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁
3.释放锁的时候通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放
六、基于ZooKeeper实现的方式
(1)创建一个目录mylock;(2)线程A想获取到锁就在mylock目录下创建临时顺序节点;(3)获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，
则说明当前线程顺序号最小，获得锁；(4)线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；
(5)线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁
优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题
缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式
