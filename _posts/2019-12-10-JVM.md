<h2>一、运行时数据区</h2>
<h3>线程私有的内存区域</h3>
<ul>
  <li>程序计数器、本地方法栈、虚拟机栈</li>
</ul>
<h3>线程共享的内存区域</h3>
<ul>
  <li>方法区、Java堆</li>
</ul>

<h2>二、线程私有的内存区域</h2>
<h3>2.1程序计数器</h3>
<p>Program Counter，简称 PC，用于存放 下一条 指令所在单元的地址，是线程所执行的字节码的行号指示器。因为JVM的多线程是通过轮流切换来分配CPU的执行时间
（时间片轮询），当切换到下一条线程的时候，线程要能知道当前要执行的字节码位置，这就要求每条线程都要有一个自己的程序计数器，
独立存储待执行的虚拟机字节码指令的地址。</p>
<h3>2.2虚拟机栈</h3>
<p>
  虚拟机栈生命周期同线程,所以不必担心垃圾回收问题。**虚拟机栈(VM Stack)**这个内存区域对应的是每个线程class方法执行的内存模型
 （不仅Java，像Kotlin、Scala、Groovy等于都可以编译成class文件并允许在JVM上）。线程中的每个方法在执行的同时都会创建一个 栈帧（Stack Frame）。
  每个class方法从被调用到执行完成的过程，都对应着一个栈帧在虚拟机栈从入栈到出栈的过程。
</p>
<p>
栈帧是用来存储 （方法内的）局部变量表、（计算时的）操作数栈、（引用的）动态链接、（进入或退出方法时的）方法出入口等。
</p>
<ul>
  <li>
    局部变量表：存放 编译期 可知的数据类型，包括 基本数据类型（boolean、byte、char、short、int、long、float、double）、对象引用（reference类型）、
    returnAddress类型（指向一条字节码指令的地址）。每个 **局部变量空间（slot）**的长度是 32位，
    而 long、double类型的每个变量占用 2个局部变量空间，也就是会占用64位空间。局部变量表所需的内存大小在编译期就已经确定，并记录在class文件中。
  </li>
  <li>
    操作数栈：栈是一个先进后出的线性表，操作数栈是逻辑计算的数据容器，比如下面的计算：
  </li>
</ul>
int a = 1;<br/>
int b = 2;<br/>
int c = 1 + 2;<br/>
retuen c;<br/>

<h2>2.3本地方法栈</h2>
<p>
  本地方法栈和虚拟机栈相似，只不过虚拟机栈是用于线程中执行Java方法（字节码，因为还有Scala、Kotlin、Groovy等其他运行在虚拟机上的编程语言），
  本地方法栈是用于执行本地的 native方法 。
</p>

<h2>三、线程共享的内存区域</h2>
<h3>3.1 堆 </h3>
<p>
  堆Heap又称 Java堆，这个内存区域是JVM线程共享的区域，也是JVM管理的最大一块内存区域。堆内存区域创建于JVM启动时。
堆的唯一目的就是存放 实例对象，反之不成立，也就是说有少量的对象实例并不在Java堆中存放，也可以在栈上分配，Java堆仅存放绝大量的对象实例。
Java堆 不像 栈 那样，随线程而生、随线程而亡。Java堆中的实例对象可能被多个线程中的变量所引用，一个线程死亡，而其他线程还可能正使用此实例对象，
所以 Java堆 成为垃圾收集器收集垃圾一个重要的区域（宏观来讲是垃圾收集器管理的主要区域）。

现在主流的垃圾收集器采用 分代收集算法，堆内存又被细分为新生代(Young Generation) 和 老年代(Old Generation)(默认比: 1:2)。
新生代 再细分为：1个Eden空间和2个Survivor空间（默认比例8:1:1）,2个Survivor空间其中一个是From Survivor空间和一个To Survivor 空间。
分代分空间的唯一理由就是优化GC性能。
</p>
<h4>常量池</h4>
<ul>
  <li>静态常量池：即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数值)字面量，还包含类、方法的信息，占用class文件绝大部分空间；</li>
  <li>运行时常量池：则是JVM虚拟机在完成 类装载 操作后，将class文件中的常量池载入到内存中，并保存在 方法区 中，我们常说的 常量池，
  就是指方法区中的运行时常量池，存放在字面量和符号引用</li>
</ul>
<h4>3.2方法区</h4>
<p>
  方法区用来存储类信息（类的版本、接口描述）、常量、静态变量、方法（数据与编译后代码）等数据，也有一些方法区的数据生命周期长，
  进而将方法区称为“永久代（Permanent Generation）”，永久存在不被GC回收，但本质上并不相等。方法区在逻辑上是和Java堆相连的，
  该区域一般GC很少参与，偶尔会存在对不使用的常量进行内存回收，对于一些卸载的类进行资源回收，因为这些数据占用内存本来就比较少，
  所以GC的回收效果也非常的一般。
</p>
<ul>
  <li>JDK1.6的永久代（PermGen）</li>
  <li>JDK1.7的永久代（PermGen）（过度阶段）</li>
  <li>JDK1.8的元空间（Metaspace）（直接内存）</li>
</ul>

<h3 style="padding-bottom:6px; padding-left:20px; color:#ffffff; background-color:#E74C3C;">类加载机制</h3>

从写好的代码到被执行完成，这都与类加载器机制密不可分。就像我们吃食物一样，先用筷子/勺子/叉子将食物放入嘴中，然后通过舌头上的味觉器官验证食物好不好吃、有没有变馊。

Java的 **“动态性”** 表现在依赖运行期动态加载和动态链接的特点实现。

首先， Java 编译器将Java源代码（.java 文件）编译成 Java字节码（.class 文件）。类加载器负责读取 .class 文件（不限于.class文件），并转换成 `java.lang.Class`类的一个实例。每个这样的实例用来表示一个 class类。所有的类加载器都是 `java.lang.ClassLoader`类的一个实例。

<h3 style="padding-bottom:6px; padding-left:20px; color:#ffffff; background-color:#E74C3C;">一、类加载过程</h3>

![类加载过程](https://upload-images.jianshu.io/upload_images/11476758-1bc7770bbd72e069.png)

#### 1.1、加载

![加载](https://i.loli.net/2018/12/17/5c179c0abadff.jpeg)

**"类加载"** 过程比较多，而加载是其中第一个步骤，负责将.class文件加载至内存，但又不仅可以从本地 `.class` 文件加载一个类或接口，也可以从JAR包、WAR包、远程网络资源获取并加载到虚拟机，通过动态代理技术可以在运行时动态生成。比如JSP文件也可以生成对应的Class类。



#### 1.2、验证

![验证](https://i.loli.net/2018/12/17/5c179c6357781.jpeg)

对加载的Class信息首先要做验证，检测文件格式、元数据、字节码等信息是否合法，是否符合虚拟机的最低要求，校验文件是否对虚拟机有害。



#### 1.3、准备

前面的文章讲过，变量所需的内存大小在编译期就已经确定，而类加载的准备阶段是为类变量分配内存并设置类变量的初始值（区别于用户指定值），这些类变量的使用的内存区域是线程共享的方法区（Method Area）。



#### 1.4、解析

![解析](https://i.loli.net/2018/12/17/5c179d350dc8f.jpeg)

虚拟机将用于标识引用的符号替换为实际指向的引用的地址。符号或符号引用只不过是个标识（描述符），而实际地址才是真正的目的内存位置。



#### 1.5、初始化

给类的静态变量初始化值，不同于准备阶段，此处是使用用于自定义的值进行赋值。



<h3 style="padding-bottom:6px; padding-left:20px; color:#ffffff; background-color:#E74C3C;">二、双亲委派模型</h3>

![双亲委派模型](https://i.loli.net/2018/12/17/5c17bc6c3f45c.png)

一个类唯一存在虚拟机的判定，是由加载它的类加载器和这个类本身共同决定。如果同一个Class类文件由不同的类加载器加载至虚拟机，那么会存在两个不同的类。

那么如何保证相同的Class类文件均有同一个类加载器加载，而且存在多样化的加载器呢？

如上图所示，顶层的 **Bootstrap ClassLoader** 是启动类加载器，所有的类最终都是有它来加载，那么同一个的Class类文件无论加载多少次，仅在虚拟机存在一个类。其他类加载器直接或间接是启动类加载的器的子类。这是一个典型的树形数据结构，从树的每个节点向上遍历总能找到根节点。那么其他类加载器仅需要将类加载的工作向上委托，最终都会委托给启动类加载（根类加载器），这样的模型称为类加载的 **双亲委派模型** 。
