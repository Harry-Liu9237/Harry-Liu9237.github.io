<h1>1.主键、外键、超键、候选键</h1>
超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。

候选键：是最小超键，即没有冗余元素的超键。

主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。

外键：在一个表中存在的另一个表的主键称此表的外键。

<h1>2.为什么用自增列作为主键</h1>
如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、

如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、

如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，
这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。

数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，
因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）

如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页

如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，
此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，
同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。

<h1>3.触发器的作用？</h1>

触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可
以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。

<h1>4.什么是存储过程？用什么来调用？</h1>

存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，
使用存储过程比单纯SQL语句执行要快。

调用：

1）可以用一个命令对象来调用存储过程。

2）可以供外部程序调用，比如：java程序。

<h1>5.存储过程的优缺点？</h1>

优点：

1）存储过程是预编译过的，执行效率高。

2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。

3）安全性高，执行存储过程需要有一定权限的用户。

4）存储过程可以重复使用，可减少数据库开发人员的工作量。

缺点：移植性差

<h1>6.存储过程和函数的区别？</h1>
    1）一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。存储过程，功能强大，可以执行包括修改表等一系列数据库操作；
    用户定义函数不能用于执行一组修改全局数据库状态的操作。

    2）对于存储过程来说可以返回参数，如记录集，而函数只能返回值或者表对象。函数只能返回一个变量；而存储过程可以返回多个。
    存储过程的参数可以有IN,OUT,INOUT三种类型，而函数只能有IN类~~存储过程声明时不需要返回类型，而函数声明时需要描述返回类型，
    且函数体中必须包含一个有效的RETURN语句。

    3）存储过程，可以使用非确定函数，不允许在用户定义函数主体中内置非确定函数。

    4）存储过程一般是作为一个独立的部分来执行（ EXECUTE 语句执行），而函数可以作为查询语句的一个部分来调用（SELECT调用），
    由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面。 SQL语句中不可用存储过程，而可以使用函数。
    
<h1>7.什么叫视图？游标是什么？</h1>
  视图：
  是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。
  对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。

  游标：

  是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。
  可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。

<h1>8..视图的优缺点</h1>

  优点：

  1)对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。

  2)用户通过简单的查询可以从复杂查询中得到结果。

  3)维护数据的独立性，试图可从多个表检索数据。

  4)对于相同的数据可产生不同的视图。

  缺点：

  性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据

  <h1>9.什么是临时表，临时表什么时候删除?</h1>
  临时表可以手动删除：
  DROP TEMPORARY TABLE IF EXISTS temp_tb;

  临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。
  创建临时表的语法与创建表语法类似，不同之处是增加关键字TEMPORARY，

  如：

  CREATE TEMPORARY TABLE tmp_table (

  NAME VARCHAR (10) NOT NULL,

  time date NOT NULL
  );

  select * from tmp_table;
  
<h1>9.非关系型数据库和关系型数据库区别，优势比较?</h1>

  非关系型数据库的优势：

  性能：NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。
  可扩展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。
  关系型数据库的优势：

  复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。
  事务支持：使得对于安全性能很高的数据访问要求得以实现。
  其他：

  1.对于这两类数据库，对方的优势就是自己的弱势，反之亦然。

  2.NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB。

  3.对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如Redis set nx。
  
<h1>10.数据库范式，根据某个场景设计数据表?</h1>
  第一范式：保证列的原子性，保证列不可再分。

  第二范式：唯一性 ；一个表只说明一个事物;有主键且非主键依赖主键；（限制多对多的关系，建立一个关联表，通过外键和联合主键来关联两张表）

  第三范式：每列都与主键有直接关系，不存在传递依赖;（限制一对多的关系，在从表中建立一个外键，通过外键来引用主表的信息）
  
<h1>11.什么是 内连接、外连接、交叉连接、笛卡尔积等?</h1>
  内连接: 只连接匹配的行

  左外连接: 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行

  右外连接: 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行

  例如1：
  SELECT a.,b. FROM luntan LEFT JOIN usertable as b ON a.username=b.username

  例如2：
  SELECT a.,b. FROM city as a FULL OUTER JOIN user as b ON a.username=b.username

  全外连接: 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。

  交叉连接: 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配

  例如：
  SELECT type,pub_name FROM titles CROSS JOIN publishers ORDER BY type

<h1>12.varchar和char的使用场景?</h1>

  1.char的长度是不可变的，而varchar的长度是可变的。

  定义一个char[10]和varchar[10]。
  如果存进去的是‘csdn’,那么char所占的长度依然为10，除了字符‘csdn’外，后面跟六个空格，varchar就立马把长度变为4了，
  取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。

  2.char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找。
  char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。
  varchar是以空间效率为首位。

  3.char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。
  varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。

  4.两者的存储数据都非unicode的字符数据。
  
<h1>13.SQL语言分类</h1>
  
  SQL语言共分为四大类：

  数据查询语言DQL
  数据操纵语言DML
  数据定义语言DDL
  数据控制语言DCL。
  1. 数据查询语言DQL

  数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：

  SELECT
  FROM
  WHERE

  2 .数据操纵语言DML

  数据操纵语言DML主要有三种形式：

  插入：INSERT

  更新：UPDATE

  删除：DELETE

  3. 数据定义语言DDL

  数据定义语言DDL用来创建数据库中的各种对象-----表、视图、索引、同义词、聚簇等如：
  CREATE TABLE/VIEW/INDEX/SYN/CLUSTER

  表 视图 索引 同义词 簇

  DDL操作是隐性提交的！不能rollback

  4. 数据控制语言DCL

  数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。如：

  GRANT：授权。

  ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。回滚---ROLLBACK；回滚命令使数据库状态回到上次最后提交的状态。其格式为：
  SQL>ROLLBACK;

  COMMIT [WORK]：提交。

  在数据库的插入、删除和修改操作时，只有当事务在提交到数据
  库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看
  到所做的事情，别人只有在最后提交完成后才可以看到。
  提交数据有三种类型：显式提交、隐式提交及自动提交。下面分
  别说明这三种类型。

  (1) 显式提交
  用COMMIT命令直接完成的提交为显式提交。其格式为：
  SQL>COMMIT；

  (2) 隐式提交
  用SQL命令间接完成的提交为隐式提交。这些命令是：
  ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，
  EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。

  (3) 自动提交
  若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，
  系统将自动进行提交，这就是自动提交。其格式为：
  SQL>SET AUTOCOMMIT ON；

<h1>14.like %和-的区别</h1>

  通配符的分类:

  %百分号通配符:表示任何字符出现任意次数(可以是0次).

  _下划线通配符:表示只能匹配单个字符,不能多也不能少,就是一个字符.

  like操作符: LIKE作用是指示mysql后面的搜索模式是利用通配符而不是直接相等匹配进行比较.

  注意: 如果在使用like操作符时,后面的没有使用通用匹配符效果是和=一致的,SELECT * FROM products WHERE products.prod_name like '1000';
  只能匹配的结果为1000,而不能匹配像JetPack 1000这样的结果.

  %通配符使用: 匹配以"yves"开头的记录:(包括记录"yves") SELECT FROM products WHERE products.prod_name like 'yves%';
  匹配包含"yves"的记录(包括记录"yves") SELECT FROM products WHERE products.prod_name like '%yves%';
  匹配以"yves"结尾的记录(包括记录"yves",不包括记录"yves ",也就是yves后面有空格的记录,这里需要注意) 
  SELECT * FROM products WHERE products.prod_name like '%yves';

  通配符使用: SELECT FROM products WHERE products.prod_name like '_yves'; 匹配结果为: 像"yyves"这样记录.
  SELECT FROM products WHERE products.prod*name like 'yves*'; 匹配结果为: 像"yvesHe"这样的记录.(一个下划线只能匹配一个字符,不能多也不能少)

  注意事项:

  注意大小写,在使用模糊匹配时,也就是匹配文本时,mysql是可能区分大小的,也可能是不区分大小写的,
  这个结果是取决于用户对MySQL的配置方式.如果是区分大小写,那么像YvesHe这样记录是不能被"yves__"这样的匹配条件匹配的.
  注意尾部空格,"%yves"是不能匹配"heyves "这样的记录的.
  注意NULL,%通配符可以匹配任意字符,但是不能匹配NULL,
  也就是说SELECT * FROM products WHERE products.prod_name like '%;是匹配不到products.prod_name为NULL的的记录.
  
<h1>15.count(*)、count(1)、count(column)的区别</h1>

  count(*)对行的数目进行计算,包含NULL

  count(column)对特定的列的值具有的行数进行计算,不包含NULL值。

  count()还有一种使用方式,count(1)这个用法和count(*)的结果是一样的。

  性能问题:

  1.任何情况下SELECT COUNT(*) FROM tablename是最优选择;

  2.尽量减少SELECT COUNT(*) FROM tablename WHERE COL = ‘value’ 这种查询;

  3.杜绝SELECT COUNT(COL) FROM tablename WHERE COL2 = ‘value’ 的出现。

  如果表没有主键,那么count(1)比count(*)快。

  如果有主键,那么count(主键,联合主键)比count(*)快。

  如果表只有一个字段,count(*)最快。

  count(1)跟count(主键)一样,只扫描主键。count(*)跟count(非主键)一样,扫描整个表。明显前者更快一些。
  
<h1>16.最左前缀原则</h1>

  多列索引：

  ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);

  为了提高搜索效率，我们需要考虑运用多列索引,由于索引文件以B－Tree格式保存，所以我们不用扫描任何记录，即可得到最终结果。

  注：在mysql中执行查询时，只能使用一个索引，如果我们在lname,fname,age上分别建索引,执行查询时，只能使用一个索引，
  mysql会选择一个最严格(获得结果集记录数最少)的索引。

  最左前缀原则：顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，
  (lname,fname)组合索引以及(lname,fname,age)组合索引。
  
  
